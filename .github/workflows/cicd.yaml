name: Backend CI/CD Pipeline

on:
  push:
    branches: 
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [member, mysub, recommend]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    - name: Setup TestContainers
      run: |
        mkdir -p ${{ matrix.service }}/src/test/resources
        if [ "${{ matrix.service }}" = "mysub" ]; then
          mkdir -p mysub-infra/src/test/resources
        fi
        echo 'docker.client.strategy=org.testcontainers.dockerclient.UnixSocketClientProviderStrategy' > ${{ matrix.service }}/src/test/resources/testcontainers.properties
        echo 'ryuk.container.privileged=true' >> ${{ matrix.service }}/src/test/resources/testcontainers.properties
        echo 'testcontainers.reuse.enable=true' >> ${{ matrix.service }}/src/test/resources/testcontainers.properties
        if [ "${{ matrix.service }}" = "mysub" ]; then
          cp ${{ matrix.service }}/src/test/resources/testcontainers.properties mysub-infra/src/test/resources/
        fi

    - name: Build application
      run: |
        if [ "${{ matrix.service }}" = "mysub" ]; then
          ./gradlew :mysub-infra:clean :mysub-infra:build -x test
        else
          ./gradlew :${{ matrix.service }}:clean :${{ matrix.service }}:build -x test
        fi

    - name: Run tests and SonarQube analysis
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      run: |
        if [ "${{ matrix.service }}" = "mysub" ]; then
          ./gradlew :mysub-infra:test :mysub-infra:jacocoTestReport :mysub-infra:sonar \
            -Dsonar.projectKey=lifesub-${{ matrix.service }}-dg0411 \
            -Dsonar.projectName=lifesub-${{ matrix.service }}-dg0411 \
            -Dsonar.java.binaries=build/classes/java/main \
            -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml \
            -Dsonar.exclusions=**/config/**,**/entity/**,**/dto/**,**/*Application.class,**/exception/**
        else
          ./gradlew :${{ matrix.service }}:test :${{ matrix.service }}:jacocoTestReport :${{ matrix.service }}:sonar \
            -Dsonar.projectKey=lifesub-${{ matrix.service }}-dg0411 \
            -Dsonar.projectName=lifesub-${{ matrix.service }}-dg0411 \
            -Dsonar.java.binaries=build/classes/java/main \
            -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml \
            -Dsonar.exclusions=**/config/**,**/entity/**,**/dto/**,**/*Application.class,**/exception/**
        fi

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.service }}-jar
        path: |
          ${{ matrix.service }}/build/libs/*.jar
          mysub-infra/build/libs/*.jar
        retention-days: 1

  quality-gate:
    runs-on: ubuntu-latest
    needs: build
    strategy:
      matrix:
        service: [member, mysub, recommend]
    
    steps:
    - name: Wait for SonarQube Quality Gate
      uses: sonarqube-quality-gate-action@master
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      with:
        scanMetadataReportFile: .scannerwork/report-task.txt

  release:
    runs-on: ubuntu-latest
    needs: [build, quality-gate]
    outputs:
      image-tag: ${{ steps.generate-tag.outputs.tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Read deployment environment variables
      run: |
        while IFS= read -r line || [ -n "$line" ]; do
          if [[ ! "$line" =~ ^# ]] && [[ "$line" =~ = ]]; then
            echo "$line" >> $GITHUB_ENV
          fi
        done < deployment/deploy_env_vars

    - name: Generate image tag
      id: generate-tag
      run: |
        TAG=$(date +'%Y%m%d%H%M%S')
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Generated image tag: $TAG"

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Azure Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.registry }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Build and push Docker images
      run: |
        for service in member mysub recommend; do
          echo "Building $service..."
          
          # Copy artifacts to correct location
          if [ "$service" = "mysub" ]; then
            mkdir -p mysub-infra/build/libs
            cp artifacts/mysub-jar/*.jar mysub-infra/build/libs/
            BUILD_LIB_DIR="mysub-infra/build/libs"
            ARTIFACT_FILE="mysub.jar"
          else
            mkdir -p $service/build/libs
            cp artifacts/${service}-jar/*.jar ${service}/build/libs/
            BUILD_LIB_DIR="${service}/build/libs"
            ARTIFACT_FILE="${service}.jar"
          fi
          
          # Build and push image
          docker build \
            --build-arg BUILD_LIB_DIR="$BUILD_LIB_DIR" \
            --build-arg ARTIFACTORY_FILE="$ARTIFACT_FILE" \
            -f deployment/container/Dockerfile \
            -t ${{ env.registry }}/${{ env.image_org }}/${service}:${{ steps.generate-tag.outputs.tag }} .
          
          docker push ${{ env.registry }}/${{ env.image_org }}/${service}:${{ steps.generate-tag.outputs.tag }}
          
          echo "Successfully built and pushed ${service}:${{ steps.generate-tag.outputs.tag }}"
        done

  deploy:
    runs-on: ubuntu-latest
    needs: release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Read deployment environment variables
      run: |
        while IFS= read -r line || [ -n "$line" ]; do
          if [[ ! "$line" =~ ^# ]] && [[ "$line" =~ = ]]; then
            echo "$line" >> $GITHUB_ENV
          fi
        done < deployment/deploy_env_vars

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group rg-digitalgarage-02 --name aks-digitalgarage-02 --overwrite-existing

    - name: Create namespace if not exists
      run: |
        kubectl create namespace ${{ env.namespace }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Generate manifest from template
      run: |
        export image_tag=${{ needs.release.outputs.image-tag }}
        export member_image_path=${{ env.registry }}/${{ env.image_org }}/member:${{ needs.release.outputs.image-tag }}
        export mysub_image_path=${{ env.registry }}/${{ env.image_org }}/mysub:${{ needs.release.outputs.image-tag }}
        export recommend_image_path=${{ env.registry }}/${{ env.image_org }}/recommend:${{ needs.release.outputs.image-tag }}
        
        envsubst < deployment/deploy.yaml.template > deployment/deploy.yaml
        
        echo "Generated manifest content:"
        cat deployment/deploy.yaml

    - name: Deploy to AKS
      run: |
        kubectl apply -f deployment/deploy.yaml
        
        echo "Waiting for deployments to be ready..."
        kubectl -n ${{ env.namespace }} wait --for=condition=available deployment/member --timeout=300s
        kubectl -n ${{ env.namespace }} wait --for=condition=available deployment/mysub --timeout=300s  
        kubectl -n ${{ env.namespace }} wait --for=condition=available deployment/recommend --timeout=300s
        
        echo "========================================="
        echo "Backend services deployment completed!"
        echo "Member Service: Ready"
        echo "MySub Service: Ready" 
        echo "Recommend Service: Ready"
        echo "Ingress Host: ${{ env.ingress_host }}"
        echo "========================================="

    - name: Verify deployment
      run: |
        echo "Checking pod status..."
        kubectl -n ${{ env.namespace }} get pods
        
        echo "Checking service status..."
        kubectl -n ${{ env.namespace }} get svc
        
        echo "Checking ingress status..."
        kubectl -n ${{ env.namespace }} get ingress